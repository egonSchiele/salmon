# Salmon

[![Build Status](https://travis-ci.org/egonSchiele/salmon.png?branch=master)](https://travis-ci.org/egonSchiele/salmon)

A transpiler to Ruby that adds some nice syntax.

Current status: Alpha.

Here's a program that you can run using Salmon right now:

```ruby
data Person name age

addAges p1 p2 := p1.age + p2.age
op <+> addAges

adit   = Person "adit" 27
maggie = Person "maggie" 28

p adit <+> maggie # prints 55
```

## Goals

1. Add some new syntax to Ruby without breaking any of the old syntax
2. Code generated should be readable (i.e. you should be able to send someone some ruby code generated by Salmon).

## Added features

### Simple classes

```ruby
data Just val
```

becomes

```ruby
Just = Struct.new(:val)
```

### Single-line functions

```
add a b := a + b
```

becomes

```ruby
def add a, b
  a + b
end
```

and

```
parse := JSON.parse . File.read . File.basename
```

becomes

```ruby
def parse(a)
  JSON.parse(File.read(File.basename(a)))
end
```

### Function composition

Function composition can be used in three places.

1. In a function definition:

```
parse := JSON.parse . File.read . File.basename
```

becomes

```ruby
def parse(a)
  JSON.parse(File.read(File.basename(a)))
end
```

2. To apply to a value:

```
a . b . c $ 5
```

becomes

```
a(b(c(5)))
```

3. And in blocks:

```
(1..10).map(&(incr . incr))
```

become

```ruby
(1..10).map { |a| incr(incr(a)) }
```

### Currying

Currying can be used in two places.

1. In functions:

```
incr = add(1, _)
```

becomes

```ruby
def incr a
  add(1, a)
end
```

2. In blocks:

```
(1..10).map(&incr)
(1..10).map(&add(1, _))
```

become:

```ruby
(1..10).map { |a| incr(a) }
(1..10).map { |a| add(1, a) }
```

You can't use currying in function composition like so:

```
add(1, _) . add(1, _) $ 5
```

Because that would create a lot of lambdas, and one goal of this project is to generate standard ruby code. So the workflow is, assign the curry to a function and then you can use it:

```
incr := add(1, _)
incr . incr $ 5
```

### Infix function names

```
1 `add` 2
```

becomes

```ruby
add(1, 2)
```

### Defining operators

You can define your own operators. For example:

```
op (<|>) either
```

Now

```
a <|> b
```

becomes

```ruby
either(a, b)
```

### fmap

```
incr <$> (1..10)
```

is the same as

```
(1..10).fmap(&incr)
```

Which is the same as:

```ruby
(1..10).map { |a| incr(a) }
```

This is because more objects are encouraged to be mappable.

For example, here's `Maybe` as a functor:

```ruby
data Maybe val

class Maybe
  def map(&blk)
    if val
      blk.call(val)
    else
      nil
    end
  end
end
```

Then you can use it:

```
JSON.parse . File.read . File.basename <$> Maybe file
```

becomes:

```ruby
Maybe.new(file).map { |x| JSON.parse(File.read(File.basename(x))) }
```

### Enums

```
enum RED | BLUE | GREEN
```

becomes

```ruby
RED = :red
BLUE = :blue
GREEN = :green
```

### Method signatures

Run-time checking using [contracts.ruby](http://github.com/egonschiele/contracts.ruby):

```
double :: Num -> Num
double x = x * 2
```

becomes:

```ruby
require 'rubygems'
require 'contracts'
include Contracts

Contract Num => Num
def double x
  x * 2
end
```
